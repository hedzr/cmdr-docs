---
layout: single
title: "[cmdr] Guide - Flags"
date: 2020-07-13 11:23:11 +0800
Author: hedzr
tags: [commander, command-line, "command-line-parser", command-line-interface,  getops, posix, posix-compatible, hierarchical-configuration, hierarchy, cli, golang]
categories: golang cmdr guide flags
comments: true
toc: true
header:
  overlay_image: /assets/images/cmdr/help-screen.png
  overlay_filter: rgba(128, 128, 0, 0.41)
excerpt: >-
  Guide and References for cmdr ...
#header:
#  overlay_image: /assets/images/unsplash-image-1.jpg
#  overlay_filter: rgba(0, 0, 0, 0.15)
#  caption: "Photo credit: [**Unsplash**](https://unsplash.com)"
#  actions:
#    - label: "More Info"
#      url: "https://unsplash.com"


---



## Flags



### 定义标志

增加一个标志（Flag）定义非常容易。

#### Bool 标志

```go
	cmdr.NewBool().
		Titles("version", "V").
		Description("display the version of Wget and exit").
		Group(cStartup).
		Action(func(cmd *cmdr.Command, args []string) (err error) {
			cmd.PrintVersion()
			return cmdr.ErrShouldBeStopException
		}).
		AttachTo(root)
```

在标志的 Action 函数体中，`retun cmdr.ErrShouldBeStopException` 能够立即终止 `cmdr`的处理循环并退出应用程序，剩余的命令行参数将被放弃。



##### 默认值

`NewBool(defaultValue...)` 要求一个（甚至是多个）可选的默认值作为其参数。

但一般情况下，我们定义一个布尔量的标志总是带有 false 默认值，因此命令行中的 `--falg` 才能翻转其值为 true。例外的情况有两个：

1. 按照 POSIX 兼容来说，在命令行中针对短标志可以采用 `-f+` 和 `-f-` 的格式来强制其值为 true 和 false。这样的话，我们可以输入这样的命令行：`-f+ -f- -f -f+ -f-`。
2. 对于 Toggleable Flags Group 的情况，一组可以像 Radio Button 一样翻转的标志组合中，通常总是有一个标志带有默认的 true 值。



##### 短标志的组合

对于布尔量的短标志来说，POSIX 要求它们能够被组合到i一起。其含义是：

```
-azro 等价于 -a -z -r -o，或者等价于 -a -zr -o
```





#### String 标志

```go
	cmdr.NewString("localhost").
    Titles("host", "host").Desc("some desc")
    Placeholder("HOST").
		Group(cStartup).
		AttachTo(root)
```

这个标志在帮助屏中的输出为：

```bash
  -host,  --host=HOST           some desc
```

占位符 `HOST` 被应用到长标题的表达形式上。

在命令行中输入时，以下的格式都是有效的：

```bash
--host=localhost
--host localhost
--hostlocalhost
```

这些格式中，单引号或双引号包围具体值均为有效形式，如 `--host'localhost'`。





#### Int, Int64, Uint, Uint64

```go
	cmdr.NewInt(2).
    Titles("retry", "r", "retry-times").Desc("retry times")
    Placeholder("COUNT").
		Group(cStartup).
		AttachTo(root)
```



#### Float32, Float64

```go
	cmdr.NewFloat32(3.14).
    Titles("pi", "pi").Desc("PI")
		Group(cStartup).
		AttachTo(root)
```





#### Complex64, Complex128

```go
  cmdr.NewComplex64(3.14+5i).
    Titles("pi", "pi").Desc("PI")
	  Group(cStartup).
	  AttachTo(root)
```


#### Duration

```go
  cmdr.NewDuration(3*time.Second).
    Titles("period", "p").Desc("period")
	  Group(cStartup).
	  AttachTo(root)
```

在命令行中输入时，可以使用 `3s`，`8m20s` 等这样的语法，它们将会翻译为等价的 `time.Duration` 值。



#### String Slice

```go
  cmdr.NewStringSlice("s1", "s2", "s3").
    Titles("add", "a").Desc("add classes")
	  Group(cStartup).
	  AttachTo(root)
```

对于所有 Slice 数组数据类型来说，命令行输入允许两种形式：

1. 多次输入：`-a s1 -a s2 -a s3`
2. 逗号分隔：`-a s1,s2,s3`

同时也允许上述两种形式任意组合。



#### Int Slice, Uint Slilce

```go
  cmdr.NewIntSlice(1, 2, 3).
    Titles("add", "a").Desc("add classes")
	  Group(cStartup).
	  AttachTo(root)
```



### Values from the Environment



### Values from config files



### Hidden



### Deprecated



### ToggleGroup



### ExternalTool



### ValidArgs



### HeadLike



### Description



### Examples



### DefaultValue



### PlaceHolder



### Option Store 配置数据

Option Store 中的配置数据来自这些地方：

- 通过 `cmdr.NewBool`, `cmdr.NewString` 等接口定义的命令行标志信息中提供的缺省值。例如：

  ```go
  	cmdr.NewBool(false).
  		Titles("enable-ueh", "ueh").
  		EnvKeys("ENABLE_UEH").
  		Description("Enables the unhandled exception handler?").
  		AttachTo(root)
  ```

  这里定义了一个 Bool 类型的标志（Flag），其默认值为 false，如果终端用户没有作出指定，则 Option Store 中会包含该条目且具有 bool 值 false。你可以通过 `cmdr.GetBoolR('enable-ueh')` 取得该值。

  > 标志总是带有默认值 false，一般较少会使用 true值。
  >
  > Toggleable Flags Group 例外，通常在组里会有一个 Flag 具有默认值 true。

- 通过命令行参数指定的。例如：

  ```bash
  $ go run ./cli --enable-ueh
  ```

  这里会通过命令行将 enable-ueh 的值设置为 true。

  此时，通过 `cmdr.GetBoolR('enable-ueh')` 取得的值将会为 true。

- 通过环境变量指定的。例如：

  ```bash
  ENABLE_UEH=1 go run /cli
  ```

  如果在定义 Flag 是没有通过 `.EnvKeys()` 指定环境变量名，`cmdr` 会试图查找自动化命名的环境变量名。例如此例中，自动化的环境变量名应该是 `APP_ENABLE_UEH`，请参考 `cmdr.WithEnvPrefix()` 的相关说明。

- 通过配置文件装入的。例如在主配置文件中包含有如下条目：

  ```yaml
  app: # 这是配置文件的前缀，可以通过 cmdr.WithOptionsPrefix() 自定义
    simple: # 这是通过 cmdr.Root(appName, version) 所指定的应用程序名
      enable-ueh: true   # 字段名称应该等于 Flag 的 Full 字段值
  
  ```

- 通过 `cmdr.Set(keyPath, value)` 设置的。















## 🔚



