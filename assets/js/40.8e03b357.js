(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{404:function(e,v,d){"use strict";d.r(v);var o=d(13),_=Object(o.a)({},(function(){var e=this,v=e.$createElement,d=e._self._c||v;return d("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[d("h1",{attrs:{id:"others"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#others"}},[e._v("#")]),e._v(" Others")]),e._v(" "),d("h2",{attrs:{id:"addons"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#addons"}},[e._v("#")]),e._v(" Addons")]),e._v(" "),d("h3",{attrs:{id:"using-isdelve"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#using-isdelve"}},[e._v("#")]),e._v(" Using "),d("code",[e._v("isdelve")])]),e._v(" "),d("p",[e._v("isdelve 几乎被内置于 "),d("code",[e._v("cmdr")]),e._v(" 中。")]),e._v(" "),d("p",[e._v("几乎，是指如果你会使用到几个特别的 API 调用的话，则 isdelve 会被自动地引用到你的项目中，否则即使你使用了 cmdr 也不会自动包含 isdelve 的相关内容。这几个特别调用是：")]),e._v(" "),d("ol",[d("li",[d("code",[e._v("cmdr.InDebugging() bool")])]),e._v(" "),d("li",[d("code",[e._v("cmdr.IsDebuggerAttached() bool")])])]),e._v(" "),d("p",[e._v("isdelve 提供的检测函数，目的在于检测 dlv 调试器有否在线。如果你的 app 被启用于一个 dlv 兼容的调试容器中，那么上述检测会返回 true 值。")]),e._v(" "),d("h4",{attrs:{id:"和-isdebugmode-的区别"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#和-isdebugmode-的区别"}},[e._v("#")]),e._v(" 和 IsDebugMode() 的区别")]),e._v(" "),d("p",[d("code",[e._v("IsDebugMode() bool")]),e._v(" 的功能是测试 "),d("code",[e._v('cmdr.GetBoolR("debug")')]),e._v(" 是否被置位。要设置这个标志，你可以在命令行中输入 "),d("code",[e._v("--debug/-D")]),e._v("，这是在 cmdr 中内建的隶属于 RootCommand 的标志，目的就在于预置一个全局的 "),d("code",[e._v("调试模式")]),e._v("。")]),e._v(" "),d("p",[e._v("一般来说，所谓的 "),d("code",[e._v("调试模式")]),e._v(" 就是为了能够输出更多的 app 运行过程中预埋的调试日志，如果你使用了 logex 集成（这是我们提供的一个用于整合 cmdr 和 logrus 的附加库），那么 "),d("code",[e._v("logrus.Debug(...)")]),e._v(" 将会在 "),d("code",[e._v("--debug")]),e._v(" 为 true 时自动被输出。")]),e._v(" "),d("blockquote",[d("p",[e._v("See also: "),d("code",[e._v("WithLogex()")])])]),e._v(" "),d("h4",{attrs:{id:"debug-vs-debug"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#debug-vs-debug"}},[e._v("#")]),e._v(" "),d("code",[e._v("--debug")]),e._v(" vs "),d("code",[e._v("~~debug")])]),e._v(" "),d("p",[e._v("要注意的是，"),d("code",[e._v("--debug")]),e._v(" 是隶属于 RootCommand 的命令行标志，它和 "),d("code",[e._v("~~debug")]),e._v(" 也有所不同。")]),e._v(" "),d("p",[d("code",[e._v("~~debug")]),e._v(" 采用 cmdr 特有的标志前缀 "),d("code",[e._v("~~")]),e._v("，这会设置一个在 Option Store 中的 "),d("code",[e._v("debug")]),e._v(" 配置项，而 "),d("code",[e._v("--debug")]),e._v(" 会设置的是 Option Store 中的 "),d("code",[e._v("app.debug")]),e._v(" 配置项。")]),e._v(" "),d("p",[e._v("所以通过 "),d("code",[e._v('cmdr.GetBoolR("debug")')]),e._v(" 能够获取到 "),d("code",[e._v("--debug")]),e._v(" 的配置值，但你无法通过 cmdr.GetBoolR() 的方式取得 "),d("code",[e._v("~~debug")]),e._v(" 的值。取而代之的是，你应该用 "),d("code",[e._v('cmdr.GetBool("debug")')]),e._v(" 来获取 "),d("code",[e._v("~~debug")]),e._v(" 的配置值。")]),e._v(" "),d("blockquote",[d("p",[e._v("GetBool(keyPath) 直接取得 keyPath 对应的配置项的值。")]),e._v(" "),d("p",[e._v("GetBoolR(keyPath) 首先为 keyPath 添加所谓的 OptionsPrefix 前缀，然后再取得新的 keyPath 所对应的配置项的值。")]),e._v(" "),d("p",[e._v('默认的 OptionsPrefix 为 "app"。')])]),e._v(" "),d("h3",{attrs:{id:"using-dex"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#using-dex"}},[e._v("#")]),e._v(" Using "),d("code",[e._v("dex")])]),e._v(" "),d("p",[e._v("🔚")])])}),[],!1,null,null,null);v.default=_.exports}}]);